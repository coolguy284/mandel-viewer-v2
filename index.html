<!doctype html>
<html>
  <head>
    <title>Mandelbrot Explorer</title>
    <style>
      html, body {
        background: black;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
      
      div {
        display: flex;
        flex-direction: column;
        align-items: center;
        align-content: center;
        flex-wrap: wrap;
        width: 100%;
        height: 100%;
      }
      
      #canvas {
        display: flex;
        flex-grow: 0;
        width: 100%;
        height: 100%;
        margin: auto;
      }
      
      #coords {
        position: absolute;
        color: white;
        left: 1vw;
        bottom: max(-3vh, -3vw);
        font-family: Impact;
        font-size: min(6vh, 6vw);
      }
    </style>
  </head>
  <body>
    <h1 id = 'coords'>X: 0, Y: 0, Scale: 1</h1>
    
    <div>
      <canvas id = 'canvas'></canvas>
    </div>
    
    <script>
      /*
        1. simple canvas test
        2. simple mandel rendering
        3. movement support
        4. scrolling support
        5. updating header numbers
        6. updating header numbers with good precision
        7. normalized iteration count
        8. fix coordinate flip
        9. inertia on scrolling
        10. fix coordinates becoming NaN on inertia due to velMag being 0 (thus division by 0)
        11. make event handlers prevent default action (primarily for scrolling if it is embedded in an iframe)
        12. add random fuzzing / artifical banding support
        zoom smoothly
        touch support
        gpu support
        
        bug when zooming after changing page zoom
      */
      let RENDER_METHOD = 1;
      let LOG_RENDER = false;
      let SMOOTH_ITERS = true,
        RANDOM_COLOR_FUZZING = false, // very slight banding is visible even with smoothed iteration count, with random fuzzing based on the real floating point value of the iteration count the banding becomes completely invisible
        DO_ARTIFICIAL_BANDING = false,
        ARTIFICIAL_BANDING_FACTOR = 1;
      let MAX_ITERS = 255;
      let SUBPIXEL_SCALE = 1;
      let ZOOM_SCALE_FACTOR = (1 / 1.5) ** (1 / 120);
      let INERTIA = true,
        INERTIA_SLOWDOWN = 10,
        INERTIA_FASTSLOWDOWN_TIME_THRESHOLD = 0.8,
        INERTIA_FASTSLOWDOWN_VEL_THRESHOLD = 3,
        INERTIA_SLOWDOWN_FACTOR = 0.1,
        INERTIA_THRESHOLD = 1e-6;
      let PREV_MOUSE_BUFFER_LENGTH = 3, // only used with inertia
        PREV_MOUSE_BUFFER_TIMESPAN = 100; // only used with inertia
      let X = 0, Y = 0, SCALE = 4;
      
      let realCanvasWidth = null, realCanvasHeight = null;
      let mouseDown = false;
      let velX = 0, velY = 0, velMag = 0;
      let targetScale = null;
      let pMouseX = null, pMouseY = null, pTimestamp = null, timeUnclicked = null;
      let previousMouseDrags = [];
      
      // https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set
      function getMandelIterct(cx, cy) {
        let qt1 = cx - 0.25;
        let q = qt1 * qt1 + cy * cy;
        if (q * (q + (cx - 0.25)) < 0.25 * cy * cy) {
          return MAX_ITERS;
        }
        
        let t1 = cx + 1.0;
        if (t1 * t1 + cy * cy < (1.0 / 16.0)) {
          return MAX_ITERS;
        }
        
        let zx = 0.0;
        let zy = 0.0;
        let zx2 = 0.0;
        let zy2 = 0.0;
        
        let iterCount = 0;
        
        while (zx2 + zy2 < 256.0 && iterCount < MAX_ITERS) {
          zy = (zx + zx) * zy + cy;
          zx = zx2 - zy2 + cx;
          zx2 = zx * zx;
          zy2 = zy * zy;
          
          iterCount++;
        }
        
        if (SMOOTH_ITERS && iterCount < MAX_ITERS) {
          let log_zn = Math.log(zx2 + zy2) / 2.0;
          let nu = Math.log(log_zn / Math.log(2.0)) / Math.log(2.0);
          
          iterCount = iterCount + 1 - nu;
        }
        
        return iterCount;
      }
      
      // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
      // A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
      function hash(x) {
        x = x + (x << 10) << 0;
        x ^= x >> 6;
        x = x + (x << 3) << 0;
        x ^= x >> 11;
        x = x + (x << 15) << 0;
        return (x & 0xffff) / 0x10000;
      }
      
      // randomly rounds up or down, biased toward the side the number is closer to
      function randomRound(val, i) {
        if (Number.isInteger(val)) {
          return val;
        }
        
        let bottom = Math.floor(val);
        let top = Math.ceil(val);
        let fraction = val - bottom;
        
        if (hash(i) > fraction) {
          return bottom;
        } else {
          return top;
        }
      }
      
      function fillMandelPixelArray(x, y, scale, width, height, pixelData) {
        for (var i = 0; i < width * height * 4; i += 4) {
          let px = Math.floor(i / 4) % width,
            py = Math.floor(i / width / 4);
          let normPx = (px - width / 2) / height,
            normPy = -(py - height / 2) / height;
          
          let cx, cy;
          
          if (LOG_RENDER) {
            let dist = Math.hypot(normPx, normPy),
              ang = Math.atan2(normPy, normPx);
            
            cx = Math.cos(ang) * (2 ** (dist * (-Math.log2(scale) + 4)) - 1) * scale + x;
            cy = Math.sin(ang) * (2 ** (dist * (-Math.log2(scale) + 4)) - 1) * scale + y;
          } else {
            cx = normPx * scale + x;
            cy = normPy * scale + y;
          }
          
          let iters = getMandelIterct(cx, cy);
          
          if (iters < MAX_ITERS) {
            let blueChannel = Math.min(-Math.cos((iters * 6 / 256) * Math.PI * 2) * 88 + 148, 255);
            if (DO_ARTIFICIAL_BANDING) {
              if (RANDOM_COLOR_FUZZING) {
                pixelData.data[i + 2] = randomRound(blueChannel / ARTIFICIAL_BANDING_FACTOR, i) * ARTIFICIAL_BANDING_FACTOR;
              } else {
                pixelData.data[i + 2] = Math.round(blueChannel / ARTIFICIAL_BANDING_FACTOR) * ARTIFICIAL_BANDING_FACTOR;
              }
            } else {
              if (RANDOM_COLOR_FUZZING) {
                pixelData.data[i + 2] = randomRound(blueChannel, i);
              } else {
                pixelData.data[i + 2] = blueChannel; // special code path for more efficient rendering
              }
            }
          } else {
            pixelData.data[i + 2] = 0;
          }
          pixelData.data[i + 3] = 255;
        }
      }
      
      function render() {
        let ctx = canvas.getContext('2d');
        let width = canvas.width, height = canvas.height;
        
        switch (RENDER_METHOD) {
          case 0:
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);
            break;
          
          case 1:
            let pixelData = ctx.createImageData(width, height);
            fillMandelPixelArray(X, Y, SCALE, width, height, pixelData);
            ctx.putImageData(pixelData, 0, 0);
            break;
        }
        
        let coordPrecision = Math.min(Math.max(-Math.log10(SCALE) + 3, 3), 16);
        
        coords.innerHTML = `X: ${X.toFixed(coordPrecision)}, Y: ${Y.toFixed(coordPrecision)}, Scale: ${SCALE.toPrecision(4)}`;
      }
      
      function resizeCanvas() {
        let style = getComputedStyle(canvas);
        realCanvasWidth = parseInt(style.width);
        realCanvasHeight = parseInt(style.height);
        canvas.width = Math.floor(realCanvasWidth * SUBPIXEL_SCALE);
        canvas.height = Math.floor(realCanvasHeight * SUBPIXEL_SCALE);
      }
      
      window.addEventListener('load', () => {
        resizeCanvas();
        render();
      });
      
      window.addEventListener('resize', () => {
        resizeCanvas();
        render();
      });
      
      window.addEventListener('mousedown', e => {
        mouseDown = true;
        
        pMouseX = e.x;
        pMouseY = e.y;
        
        e.preventDefault();
      });
      
      window.addEventListener('mouseup', e => {
        if (INERTIA) {
          timeUnclicked = performance.now();
          let minValidTime = timeUnclicked - PREV_MOUSE_BUFFER_TIMESPAN;
          
          let mouseDragSum = previousMouseDrags.filter(x => x[2] > minValidTime).reduce((a, c) => [a[0] + c[0], a[1] + c[1]], [0, 0]);
          let mouseDrag = previousMouseDrags.length ? [mouseDragSum[0] / previousMouseDrags.length, mouseDragSum[1] / previousMouseDrags.length] : [0, 0];
          
          velX = mouseDrag[0];
          velY = mouseDrag[1];
          
          previousMouseDrags.splice(0, Infinity);
        }
        
        mouseDown = false;
        
        e.preventDefault();
      });
      
      window.addEventListener('mousemove', e => {
        if (INERTIA) {
          if (mouseDown) {
            velX = e.x - pMouseX;
            velY = -e.y + pMouseY;
            
            velMag = Math.hypot(velX, velY);
            
            X -= velX / realCanvasHeight * SCALE;
            Y -= velY / realCanvasHeight * SCALE;
          }
          
          pMouseX = e.x;
          pMouseY = e.y;
          
          previousMouseDrags.push([velX, velY, performance.now()]);
          if (previousMouseDrags.length > PREV_MOUSE_BUFFER_LENGTH) {
            previousMouseDrags.splice(0, 1);
          }
          
          if (mouseDown) {
            movementLoop();
          }
        } else {
          if (mouseDown) {
            let deltaX = e.x - pMouseX, deltaY = -e.y + pMouseY;
            
            X -= deltaX / realCanvasHeight * SCALE;
            Y -= deltaY / realCanvasHeight * SCALE;
            
            render();
          }
          
          pMouseX = e.x;
          pMouseY = e.y;
        }
        
        e.preventDefault();
      });
      
      window.addEventListener('wheel', e => {
        if (INERTIA) {
          let scaleFactor = ZOOM_SCALE_FACTOR ** e.wheelDelta;
          
          let cxCursor = X + (pMouseX - realCanvasWidth / 2) / realCanvasHeight * SCALE;
          let cyCursor = Y + -(pMouseY - realCanvasHeight / 2) / realCanvasHeight * SCALE;
          
          let cxDiff = cxCursor - X;
          let cyDiff = cyCursor - Y;
          
          let cxScaleDiff = cxDiff - cxDiff * scaleFactor;
          let cyScaleDiff = cyDiff - cyDiff * scaleFactor;
          
          X += cxScaleDiff;
          Y += cyScaleDiff;
          
          SCALE *= scaleFactor;
          
          render();
          
          velX = 0;
          velY = 0;
        } else {
          let scaleFactor = ZOOM_SCALE_FACTOR ** e.wheelDelta;
          
          let cxCursor = X + (pMouseX - realCanvasWidth / 2) / realCanvasHeight * SCALE;
          let cyCursor = Y + -(pMouseY - realCanvasHeight / 2) / realCanvasHeight * SCALE;
          
          let cxDiff = cxCursor - X;
          let cyDiff = cyCursor - Y;
          
          let cxScaleDiff = cxDiff - cxDiff * scaleFactor;
          let cyScaleDiff = cyDiff - cyDiff * scaleFactor;
          
          X += cxScaleDiff;
          Y += cyScaleDiff;
          
          SCALE *= scaleFactor;
          
          render();
        }
        
        e.preventDefault();
      }, { passive: false });
      
      let movementLoopRunning = false;
      
      function movementLoop(timestamp) {
        if (movementLoopRunning && !timestamp) return;
        
        movementLoopRunning = true;
        
        if (!mouseDown) {
          X -= velX / realCanvasHeight * SCALE;
          Y -= velY / realCanvasHeight * SCALE;
        
          if (pTimestamp) {
            let lastFrameTime = (timestamp - pTimestamp) / 1000;
            let timeSinceUnclicked = (timestamp - timeUnclicked) / 1000;
            
            let newVelMag;
            if (timeSinceUnclicked > INERTIA_FASTSLOWDOWN_TIME_THRESHOLD && velMag > INERTIA_FASTSLOWDOWN_VEL_THRESHOLD) {
              // bigger for fast speeds
              newVelMag = Math.max((velMag - INERTIA_SLOWDOWN * lastFrameTime * 7) * INERTIA_SLOWDOWN_FACTOR ** lastFrameTime, 0);
            } else {
              // linear for slow speeds
              newVelMag = Math.max(velMag - INERTIA_SLOWDOWN * lastFrameTime, 0);
            }
            
            let slowdownFactor = velMag != 0 ? newVelMag / velMag : 0;
            
            velX *= slowdownFactor;
            velY *= slowdownFactor;
            
            velMag = newVelMag;
          }
        }
        
        render();
        
        if (Math.abs(velX) < INERTIA_THRESHOLD && Math.abs(velY) < INERTIA_THRESHOLD) {
          movementLoopRunning = false;
          pTimestamp = null;
        } else {
          pTimestamp = timestamp;
          requestAnimationFrame(movementLoop);
        }
      }
    </script>
  </body>
</html>
