<!doctype html>
<html>
  <head>
    <title>Mandelbrot Explorer</title>
    <style>
      html, body {
        background: black;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
      
      div {
        display: flex;
        flex-direction: column;
        align-items: center;
        align-content: center;
        flex-wrap: wrap;
        width: 100%;
        height: 100%;
      }
      
      #canvas {
        display: flex;
        flex-grow: 0;
        width: 100%;
        height: 100%;
        margin: auto;
      }
      
      #coords {
        position: absolute;
        color: white;
        left: 1vw;
        bottom: max(-3vh, -3vw);
        font-family: Impact;
        font-size: min(6vh, 6vw);
      }
    </style>
  </head>
  <body>
    <h1 id = 'coords' style = 'display: none;'>X: 0, Y: 0, Scale: 1</h1>
    
    <div>
      <canvas id = 'canvas'></canvas>
    </div>
    
    <script>
      /*
        1. simple canvas test
        2. simple mandel rendering
        3. movement support
        4. scrolling support
        5. updating header numbers
        6. updating header numbers with good precision
        7. normalized iteration count
        8. fix coordinate flip
        9. inertia on scrolling
        10. fix coordinates becoming NaN on inertia due to velMag being 0 (thus division by 0)
        11. make event handlers prevent default action (primarily for scrolling if it is embedded in an iframe)
        12. add random fuzzing / artifical banding support
        13. zoom smoothly
        14. remove preventdefault on mousedown, up, move
        15. update log rendering mode
        16. add other color palletes
        17. esc key to reset position
        touch support
        settings menu
        gpu support
        
        bug when zooming after changing page zoom; zoom is relative to point outside screen (zooming in) or much closer to center (zooming out)
        bug on move and zoom; one frame delay on move and zoom before motion occurs, especially noticeable when render takes 1/5 second
      */
      
      let X = 0, Y = 0, SCALE = 4; // coordinates for mandelbrot set
      /*
        interesting places:
        X = -0.10109636384562178, Y = 0.9562865108091415, SCALE = 9.603811037451508e-15; LOG_ZOOM = 2; top spiral
      */
      
      let PALLETE = 0; // 0 - blue, 1 - green, 2 - red, 3 - rainbow
      let LOG_RENDER = 0; // convert distance from center of screen to an exponential coordinate, allows most of mandelbrot zoom to be viewed at once; 0 - no log render, 1 - 50% of mandelbrot set zoom is visible, 2 - full mandelbrot set is always visible, albeit distorted
      let SMOOTH_ITERS = true; // calculate fractional iteration count and color smoothly
      
      let RENDER_METHOD = 1; // 0 - fillRect canvas test, 1 - js calculations and manual pixel setting, 2 - webgl shader
      let MAX_ITERS = 255; // depth of mandelbrot calculation
      let INERTIA = true; // smooth movement and scroll
      let SHOW_COORDINATES = true; // whether coordinates are shown in bottom right hand corner
      
      let RANDOM_COLOR_FUZZING = false, // very slight banding is visible even with smoothed iteration count, with random fuzzing based on the real floating point value of the iteration count the banding becomes completely invisible
        DO_ARTIFICIAL_BANDING = false, // quantize iteration count after calculating smooth iteration count, primarily used to test random color fuzzing
        ARTIFICIAL_BANDING_FACTOR = 1; // factor of quantization, 2 makes color channel even, 3 makes color channel a multiple of 3, etc.
      let SUBPIXEL_SCALE = 1; // default ratio of canvas pixel size to true canvas size, 0 < x < 1 to render faster but more pixelated, x > 1 to supersample and make higher quality image
      let ZOOM_SCALE_FACTOR = (1 / 1.5) ** (1 / 120); // amount that image scale is changed per unit of mouse delta (normal scroll is 120 delta)
      let INERTIA_SLOWDOWN = 10, // pixel speed amount that is decreased every second
        INERTIA_FASTSLOWDOWN_TIME_THRESHOLD = 0.8, // amount of seconds of slow inertia slowdown before fast slowdown begins, must also be moving faster than velocity threshold
        INERTIA_FASTSLOWDOWN_VEL_THRESHOLD = 3, // pixel speed must be above this value before fast slowdown begins, must also be after the time threshold
        INERTIA_SLOWDOWN_FACTOR = 0.1, // smaller to slowdown faster in fast slowdown, hard to understand unit so just experiment
        INERTIA_MOVE_THRESHOLD = 1e-6, // minimum pixel velocity of the canvas to perform a move
        INERTIA_ZOOM_FACTOR = 20, // bigger to reach target zoom faster, hard to understand unit so just experiment
        INERTIA_ZOOM_THRESHOLD = 1e-2; // minimum natural log difference between target and current scale to perform a zoom operation
      let PREV_MOUSE_BUFFER_LENGTH = 3, // number of previous mouse inputs used to calculate average speed to apply to canvas; only used with inertia
        PREV_MOUSE_BUFFER_TIMESPAN = 0.1 * 1000; // maximum time in past to include mouse inputs in the previous mouse buffer; only used with inertia
      
      let realCanvasWidth = null, realCanvasHeight = null;
      let mouseDown = false;
      let velX = 0, velY = 0, velMag = 0;
      let targetScale = SCALE, targetScalePMouseX = null, targetScalePMouseY = null;
      let pMouseX = null, pMouseY = null, pTimestamp = null, timeUnclicked = null;
      let previousMouseDrags = [];
      
      // https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set
      function getMandelIterct(cx, cy) {
        let qt1 = cx - 0.25;
        let q = qt1 * qt1 + cy * cy;
        if (q * (q + (cx - 0.25)) < 0.25 * cy * cy) {
          return MAX_ITERS;
        }
        
        let t1 = cx + 1.0;
        if (t1 * t1 + cy * cy < (1.0 / 16.0)) {
          return MAX_ITERS;
        }
        
        let zx = 0.0;
        let zy = 0.0;
        let zx2 = 0.0;
        let zy2 = 0.0;
        
        let iterCount = 0;
        
        while (zx2 + zy2 < 256.0 && iterCount < MAX_ITERS) {
          zy = (zx + zx) * zy + cy;
          zx = zx2 - zy2 + cx;
          zx2 = zx * zx;
          zy2 = zy * zy;
          
          iterCount++;
        }
        
        if (SMOOTH_ITERS && iterCount < MAX_ITERS) {
          let log_zn = Math.log(zx2 + zy2) / 2.0;
          let nu = Math.log(log_zn / Math.log(2.0)) / Math.log(2.0);
          
          iterCount = iterCount + 1 - nu;
        }
        
        return iterCount;
      }
      
      // https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl
      // A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
      function hash(x) {
        x = x + (x << 10) << 0;
        x ^= x >> 6;
        x = x + (x << 3) << 0;
        x ^= x >> 11;
        x = x + (x << 15) << 0;
        return (x & 0xffff) / 0x10000;
      }
      
      // randomly rounds up or down, biased toward the side the number is closer to
      function randomRound(val, i) {
        if (Number.isInteger(val)) {
          return val;
        }
        
        let bottom = Math.floor(val);
        let top = Math.ceil(val);
        let fraction = val - bottom;
        
        if (hash(i) > fraction) {
          return bottom;
        } else {
          return top;
        }
      }
      
      function getRainbowIntIterColor(iters) {
        //return [float(iters) / float(MAX_ITERS) * 5.0, 0, 0];
        
        if (iters < 0 || iters >= MAX_ITERS) return [0, 0, 0];
        
        let itersMod = (-(iters - 1) % 24 + 24) % 24;  // minus sign at front because backwards rainbow looks better
        
        switch (itersMod) {
          case 0: return [1, 0, 0];
          case 1: return [1, 0.25, 0];
          case 2: return [1, 0.5, 0];
          case 3: return [1, 0.75, 0];
          case 4: return [1, 1, 0];
          case 5: return [0.75, 1, 0];
          case 6: return [0.5, 1, 0];
          case 7: return [0.25, 1, 0];
          case 8: return [0, 1, 0];
          case 9: return [0, 1, 0.25];
          case 10: return [0, 1, 0.5];
          case 11: return [0, 1, 0.75];
          case 12: return [0, 1, 1];
          case 13: return [0, 0.75, 1];
          case 14: return [0, 0.5, 1];
          case 15: return [0, 0.25, 1];
          case 16: return [0, 0, 1];
          case 17: return [0.25, 0, 1];
          case 18: return [0.5, 0, 1];
          case 19: return [0.75, 0, 1];
          case 20: return [1, 0, 1];
          case 21: return [1, 0, 0.75];
          case 22: return [1, 0, 0.5];
          case 23: return [1, 0, 0.25];
          default: return [0, 0, 0]; // should be impossible branch but here to remove the warning
        }
      }
      
      function getRainbowIterColor(iters) {
        if (Number.isInteger(iters)) {
          return getRainbowIntIterColor(iters);
        }
        
        let itersFloor = Math.floor(iters);
        let itersCeil = Math.ceil(iters);
        let itersFrac = iters - itersFloor;
        
        let itersFloorColor = getRainbowIntIterColor(itersFloor);
        let itersCeilColor = getRainbowIntIterColor(itersCeil);
        
        return [
          itersFloorColor[0] + (itersCeilColor[0] - itersFloorColor[0]) * itersFrac,
          itersFloorColor[1] + (itersCeilColor[1] - itersFloorColor[1]) * itersFrac,
          itersFloorColor[2] + (itersCeilColor[2] - itersFloorColor[2]) * itersFrac,
        ];
      }
      
      function fillMandelPixelArray(x, y, scale, width, height, pixelData) {
        for (var i = 0; i < width * height * 4; i += 4) {
          let px = Math.floor(i / 4) % width,
            py = Math.floor(i / width / 4);
          let normPx = (px - width / 2) / height, // normalized to -0.5 - 0.5, NOT -1 - 1
            normPy = -(py - height / 2) / height; // normalized to -0.5 - 0.5, NOT -1 - 1
          
          let cx, cy;
          
          switch (LOG_RENDER) {
            case 0:
              cx = normPx * scale + x;
              cy = normPy * scale + y;
              break;
            
            case 1: {
              let dist = Math.hypot(normPx, normPy),
                ang = Math.atan2(normPy, normPx);
              
              cx = Math.cos(ang) * (2 ** (dist * (-Math.log2(scale) + 4)) - 1) * scale + x;
              cy = Math.sin(ang) * (2 ** (dist * (-Math.log2(scale) + 4)) - 1) * scale + y;
              } break;
            
            case 2: {
              let dist = Math.hypot(normPx, normPy) * 2,
                ang = Math.atan2(normPy, normPx);
              
              cx = Math.cos(ang) * (2 ** (dist * (-Math.log2(Math.min(scale, 1)) + 1.7)) - 1) * scale + x;
              cy = Math.sin(ang) * (2 ** (dist * (-Math.log2(Math.min(scale, 1)) + 1.7)) - 1) * scale + y;
              } break;
          }
          
          let iters = getMandelIterct(cx, cy);
          
          if (PALLETE >= 0 && PALLETE <= 2) {
            let index;
            
            switch (PALLETE) {
              case 0: index = i + 2; break;
              case 1: index = i + 1; break;
              case 2: index = i; break;
            }
            
            if (iters < MAX_ITERS) {
              let colorVal = Math.min(-Math.cos((iters * 6 / 256) * Math.PI * 2) * 88 + 148, 256);
              if (DO_ARTIFICIAL_BANDING) {
                if (RANDOM_COLOR_FUZZING) {
                  pixelData.data[index] = randomRound(colorVal / ARTIFICIAL_BANDING_FACTOR, i) * ARTIFICIAL_BANDING_FACTOR;
                } else {
                  pixelData.data[index] = Math.round(colorVal / ARTIFICIAL_BANDING_FACTOR) * ARTIFICIAL_BANDING_FACTOR;
                }
              } else {
                if (RANDOM_COLOR_FUZZING) {
                  pixelData.data[index] = randomRound(colorVal, i);
                } else {
                  pixelData.data[index] = colorVal; // special code path for more efficient rendering
                }
              }
            } else {
              pixelData.data[index] = 0;
            }
          } else if (PALLETE == 3) {
            let color = getRainbowIterColor(iters);
            
            if (DO_ARTIFICIAL_BANDING) {
              if (RANDOM_COLOR_FUZZING) {
                pixelData.data[i] = randomRound(color[0] * 256 / ARTIFICIAL_BANDING_FACTOR, i) * ARTIFICIAL_BANDING_FACTOR;
                pixelData.data[i + 1] = randomRound(color[1] * 256 / ARTIFICIAL_BANDING_FACTOR, i) * ARTIFICIAL_BANDING_FACTOR;
                pixelData.data[i + 2] = randomRound(color[2] * 256 / ARTIFICIAL_BANDING_FACTOR, i) * ARTIFICIAL_BANDING_FACTOR;
              } else {
                pixelData.data[i] = Math.round(color[0] * 256 / ARTIFICIAL_BANDING_FACTOR) * ARTIFICIAL_BANDING_FACTOR;
                pixelData.data[i + 1] = Math.round(color[1] * 256 / ARTIFICIAL_BANDING_FACTOR) * ARTIFICIAL_BANDING_FACTOR;
                pixelData.data[i + 2] = Math.round(color[2] * 256 / ARTIFICIAL_BANDING_FACTOR) * ARTIFICIAL_BANDING_FACTOR;
              }
            } else {
              if (RANDOM_COLOR_FUZZING) {
                pixelData.data[i] = randomRound(color[0] * 256, i);
                pixelData.data[i + 1] = randomRound(color[1] * 256, i);
                pixelData.data[i + 2] = randomRound(color[2] * 256, i);
              } else {
                // special code path for more efficient rendering
                pixelData.data[i] = color[0] * 256;
                pixelData.data[i + 1] = color[1] * 256;
                pixelData.data[i + 2] = color[2] * 256;
              }
            }
          }
          
          pixelData.data[i + 3] = 255;
        }
      }
      
      function render() {
        let ctx = canvas.getContext('2d');
        let width = canvas.width, height = canvas.height;
        
        switch (RENDER_METHOD) {
          case 0:
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);
            break;
          
          case 1:
            let pixelData = ctx.createImageData(width, height);
            fillMandelPixelArray(X, Y, SCALE, width, height, pixelData);
            ctx.putImageData(pixelData, 0, 0);
            break;
        }
        
        let coordPrecision = Math.min(Math.max(-Math.log10(SCALE) + 3, 3), 16);
        
        if (SHOW_COORDINATES) {
          if (coords.style.display == 'none') {
            coords.style.display = '';
          }
        } else {
          if (coords.style.display != 'none') {
            coords.style.display = 'none';
          }
        }
        coords.innerHTML = `X: ${X.toFixed(coordPrecision)}, Y: ${Y.toFixed(coordPrecision)}, Scale: ${SCALE.toPrecision(4)}`;
      }
      
      function resizeCanvas() {
        let style = getComputedStyle(canvas);
        
        realCanvasWidth = parseInt(style.width);
        realCanvasHeight = parseInt(style.height);
        
        canvas.width = Math.floor(realCanvasWidth * SUBPIXEL_SCALE);
        canvas.height = Math.floor(realCanvasHeight * SUBPIXEL_SCALE);
      }
      
      window.addEventListener('load', () => {
        resizeCanvas();
        render();
      });
      
      window.addEventListener('resize', () => {
        resizeCanvas();
        render();
      });
      
      window.addEventListener('mousedown', e => {
        mouseDown = true;
        
        pMouseX = e.x;
        pMouseY = e.y;
      });
      
      window.addEventListener('mouseup', e => {
        if (INERTIA) {
          timeUnclicked = performance.now();
          let minValidTime = timeUnclicked - PREV_MOUSE_BUFFER_TIMESPAN;
          
          let mouseDragSum = previousMouseDrags.filter(x => x[2] > minValidTime).reduce((a, c) => [a[0] + c[0], a[1] + c[1]], [0, 0]);
          let mouseDrag = previousMouseDrags.length ? [mouseDragSum[0] / previousMouseDrags.length, mouseDragSum[1] / previousMouseDrags.length] : [0, 0];
          
          velX = mouseDrag[0];
          velY = mouseDrag[1];
          
          previousMouseDrags.splice(0, Infinity);
        }
        
        mouseDown = false;
      });
      
      window.addEventListener('mousemove', e => {
        if (INERTIA) {
          if (mouseDown) {
            velX = e.x - pMouseX;
            velY = -e.y + pMouseY;
            
            velMag = Math.hypot(velX, velY);
            
            X -= velX / realCanvasHeight * SCALE;
            Y -= velY / realCanvasHeight * SCALE;
          }
          
          pMouseX = e.x;
          pMouseY = e.y;
          
          previousMouseDrags.push([velX, velY, performance.now()]);
          if (previousMouseDrags.length > PREV_MOUSE_BUFFER_LENGTH) {
            previousMouseDrags.splice(0, 1);
          }
          
          if (mouseDown) {
            movementLoop();
          }
        } else {
          if (mouseDown) {
            let deltaX = e.x - pMouseX, deltaY = -e.y + pMouseY;
            
            X -= deltaX / realCanvasHeight * SCALE;
            Y -= deltaY / realCanvasHeight * SCALE;
            
            render();
          }
          
          pMouseX = e.x;
          pMouseY = e.y;
        }
      });
      
      window.addEventListener('wheel', e => {
        if (INERTIA) {
          let scaleFactor = ZOOM_SCALE_FACTOR ** e.wheelDelta;
          
          targetScale *= scaleFactor;
          targetScalePMouseX = pMouseX;
          targetScalePMouseY = pMouseY;
          
          if (!mouseDown) {
            velX = 0;
            velY = 0;
          }
          
          movementLoop();
        } else {
          let scaleFactor = ZOOM_SCALE_FACTOR ** e.wheelDelta;
          
          let cxCursor = X + (pMouseX - realCanvasWidth / 2) / realCanvasHeight * SCALE;
          let cyCursor = Y + -(pMouseY - realCanvasHeight / 2) / realCanvasHeight * SCALE;
          
          let cxDiff = cxCursor - X;
          let cyDiff = cyCursor - Y;
          
          let cxScaleDiff = cxDiff - cxDiff * scaleFactor;
          let cyScaleDiff = cyDiff - cyDiff * scaleFactor;
          
          X += cxScaleDiff;
          Y += cyScaleDiff;
          
          SCALE *= scaleFactor;
          
          render();
        }
        
        e.preventDefault();
      }, { passive: false });
      
      window.addEventListener('keydown', e => {
        if (e.keyCode == 27) {
          // escape key pressed
          
          if (INERTIA) {
            velX = 0;
            velY = 0;
            X = 0;
            Y = 0;
            SCALE = 4;
            targetScale = 4;
          } else {
            X = 0;
            Y = 0;
            SCALE = 4;
          }
          
          render();
        }
      });
      
      let movementLoopRunning = false;
      
      function movementLoop(timestamp) {
        if (movementLoopRunning && !timestamp) return;
        
        movementLoopRunning = true;
        
        let processMovement = Math.abs(velX) >= INERTIA_MOVE_THRESHOLD ||
          Math.abs(velY) >= INERTIA_MOVE_THRESHOLD;
        let processZoom = Math.abs(Math.log(targetScale / SCALE)) >= INERTIA_ZOOM_THRESHOLD;
        
        let lastFrameTime;
        if (pTimestamp) {
          lastFrameTime = (timestamp - pTimestamp) / 1000;
        }
        
        // movement processing
        
        if (processMovement) {
          if (!mouseDown) {
            X -= velX / realCanvasHeight * SCALE;
            Y -= velY / realCanvasHeight * SCALE;
          
            if (pTimestamp) {
              let newVelMag;
              let timeSinceUnclicked =  (timestamp - timeUnclicked) / 1000;
              if (timeSinceUnclicked > INERTIA_FASTSLOWDOWN_TIME_THRESHOLD && velMag > INERTIA_FASTSLOWDOWN_VEL_THRESHOLD) {
                // bigger for fast speeds
                newVelMag = Math.max((velMag - INERTIA_SLOWDOWN * lastFrameTime) * INERTIA_SLOWDOWN_FACTOR ** lastFrameTime, 0);
              } else {
                // linear for slow speeds
                newVelMag = Math.max(velMag - INERTIA_SLOWDOWN * lastFrameTime, 0);
              }
              
              let slowdownFactor = velMag != 0 ? newVelMag / velMag : 0;
              
              velX *= slowdownFactor;
              velY *= slowdownFactor;
              
              velMag = newVelMag;
            }
          }
        }
        
        // zoom processing
        
        if (processZoom && pTimestamp) {
          let scaleFactor = Math.E ** (Math.log(targetScale / SCALE) * Math.min(INERTIA_ZOOM_FACTOR * lastFrameTime, 1));
          
          let cxCursor = X + (targetScalePMouseX - realCanvasWidth / 2) / realCanvasHeight * SCALE;
          let cyCursor = Y + -(targetScalePMouseY - realCanvasHeight / 2) / realCanvasHeight * SCALE;
          
          let cxDiff = cxCursor - X;
          let cyDiff = cyCursor - Y;
          
          let cxScaleDiff = cxDiff - cxDiff * scaleFactor;
          let cyScaleDiff = cyDiff - cyDiff * scaleFactor;
          
          X += cxScaleDiff;
          Y += cyScaleDiff;
          
          SCALE *= scaleFactor;
        }
        
        // render
        
        render();
        
        if (Math.abs(velX) < INERTIA_MOVE_THRESHOLD &&
            Math.abs(velY) < INERTIA_MOVE_THRESHOLD &&
            Math.abs(Math.log(targetScale / SCALE)) < INERTIA_ZOOM_THRESHOLD) {
          movementLoopRunning = false;
          pTimestamp = null;
        } else {
          pTimestamp = timestamp;
          requestAnimationFrame(movementLoop);
        }
      }
    </script>
  </body>
</html>
